import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";

interface MealItem {
  besinName: string;
  miktar: string;
  birim: string;
}

interface MealPattern {
  name: string;
  items: MealItem[];
  count: number;
  score: number;
}

export async function POST(request: NextRequest) {
  try {
    // Get last 30 diets
    const diets = await prisma.diet.findMany({
      take: 30,
      orderBy: {
        createdAt: "desc",
      },
      include: {
        oguns: {
          include: {
            items: {
              include: {
                besin: true,
                birim: true,
              },
            },
          },
        },
      },
    });

    if (diets.length < 5) {
      return NextResponse.json(
        { error: "En az 5 diyet gerekli. Daha fazla diyet yazın." },
        { status: 400 }
      );
    }

    // Group meals by name (kahvaltı, öğle, etc.)
    const mealGroups: { [key: string]: any[] } = {};

    diets.forEach((diet) => {
      diet.oguns.forEach((ogun) => {
        const normalizedName = normalizeMealName(ogun.name);
        if (!mealGroups[normalizedName]) {
          mealGroups[normalizedName] = [];
        }

        // Convert items to simplified format
        const mealItems = ogun.items
          .map((item) => ({
            besinName: item.besin?.name || "",
            miktar: item.miktar || "",
            birim: item.birim?.name || "",
          }))
          .filter((item) => item.besinName); // Only non-empty

        if (mealItems.length > 0) {
          mealGroups[normalizedName].push({
            name: ogun.name,
            items: mealItems,
          });
        }
      });
    });

    // Detect patterns for each meal type
    const detectedPatterns: MealPattern[] = [];

    for (const [mealType, meals] of Object.entries(mealGroups)) {
      if (meals.length < 3) continue; // Need at least 3 samples

      const patterns = findSimilarPatterns(meals, mealType);
      detectedPatterns.push(...patterns);
    }

    // Create presets from patterns (only high-score ones)
    const createdPresets: any[] = [];
    for (const pattern of detectedPatterns) {
      if (pattern.score < 60) continue; // Only patterns with 60%+ similarity

      // Check if similar preset already exists
      const existing = await prisma.mealPreset.findFirst({
        where: {
          name: pattern.name,
          isAutoGenerated: true,
        },
      });

      if (existing) {
        // Update score
        await prisma.mealPreset.update({
          where: { id: existing.id },
          data: {
            patternScore: pattern.score,
          },
        });
      } else {
        // Create new preset
        const preset = await prisma.mealPreset.create({
          data: {
            name: pattern.name,
            mealType: getMealTypeCategory(pattern.name),
            isAutoGenerated: true,
            patternScore: pattern.score,
            isActive: true,
            items: {
              create: pattern.items.map((item, idx) => ({
                besinName: item.besinName,
                miktar: item.miktar,
                birim: item.birim,
                order: idx,
              })),
            },
          },
          include: {
            items: true,
          },
        });

        createdPresets.push(preset);
      }
    }

    return NextResponse.json({
      message: `${createdPresets.length} yeni preset oluşturuldu`,
      presets: createdPresets,
      patternsDetected: detectedPatterns.length,
    });
  } catch (error) {
    console.error("Error auto-generating presets:", error);
    return NextResponse.json(
      { error: "Otomatik preset oluşturulurken bir hata oluştu" },
      { status: 500 }
    );
  }
}

// Helper: Normalize meal names
function normalizeMealName(name: string): string {
  const lower = name.toLowerCase().trim();
  if (lower.includes("kahvaltı")) return "kahvaltı";
  if (lower.includes("öğle")) return "öğle";
  if (lower.includes("akşam")) return "akşam";
  if (lower.includes("ara")) return "ara_öğün";
  return "diğer";
}

// Helper: Get meal type category
function getMealTypeCategory(name: string): string {
  const lower = name.toLowerCase();
  if (lower.includes("kahvaltı")) return "kahvalti";
  if (lower.includes("öğle")) return "ogle";
  if (lower.includes("akşam")) return "aksam";
  if (lower.includes("ara")) return "ara_ogun";
  return "diger";
}

// Helper: Find similar patterns
function findSimilarPatterns(meals: any[], mealType: string): MealPattern[] {
  const patterns: MealPattern[] = [];

  // Compare each meal with others
  for (let i = 0; i < meals.length; i++) {
    let similarCount = 0;
    const baseMeal = meals[i];

    for (let j = 0; j < meals.length; j++) {
      if (i === j) continue;

      const similarity = calculateMealSimilarity(
        baseMeal.items,
        meals[j].items
      );
      if (similarity >= 0.7) {
        // 70% similarity threshold
        similarCount++;
      }
    }

    const score = (similarCount / meals.length) * 100;

    if (score >= 60) {
      // At least 60% of meals are similar
      patterns.push({
        name: `Sık Kullanılan ${capitalize(mealType)}`,
        items: baseMeal.items,
        count: similarCount + 1,
        score: Math.round(score),
      });
      break; // Only take the most common pattern
    }
  }

  return patterns;
}

// Helper: Calculate similarity between two meals
function calculateMealSimilarity(
  items1: MealItem[],
  items2: MealItem[]
): number {
  if (items1.length === 0 || items2.length === 0) return 0;

  let matchCount = 0;

  items1.forEach((item1) => {
    const match = items2.find(
      (item2) =>
        item2.besinName.toLowerCase() === item1.besinName.toLowerCase() &&
        item2.miktar === item1.miktar &&
        item2.birim === item1.birim
    );
    if (match) matchCount++;
  });

  // Similarity = (matched items / total unique items)
  const totalItems = Math.max(items1.length, items2.length);
  return matchCount / totalItems;
}

// Helper: Capitalize first letter
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
